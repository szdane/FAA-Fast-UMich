#!/usr/bin/env python3
"""
animate_two_trajectories.py
===========================

Create a 3‑D animation of two aircraft trajectories generated by
milp_two_flights.py.

Examples
--------

# 1. Play interactively in a window
python animate_two_trajectories.py --solution_csv sol.csv

# 2. Save as a GIF (requires Pillow)
python animate_two_trajectories.py --solution_csv sol.csv \
       --save_gif flights.gif --fps 6

# 3. Save as MP4 (requires ffmpeg)
python animate_two_trajectories.py --solution_csv sol.csv \
       --save_mp4 flights.mp4 --fps 24

Dependencies
------------
pip install pandas matplotlib pillow  # (+ ffmpeg if MP4 output)
"""
import argparse
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter, FFMpegWriter
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 – needed for 3‑D backend


# --------------------------------------------------------------------------
def build_parser():
    p = argparse.ArgumentParser(description="Animate two 4‑D trajectories")
    p.add_argument("--solution_csv", required=True,
                   help="CSV with t,x1,y1,z1,x2,y2,z2 columns")
    p.add_argument("--fps", type=int, default=8,
                   help="Frames per second for saved file or live playback")
    p.add_argument("--save_gif", type=str, default=None,
                   help="Filename to save a GIF (uses PillowWriter)")
    p.add_argument("--save_mp4", type=str, default=None,
                   help="Filename to save an MP4 (needs ffmpeg)")
    return p


# --------------------------------------------------------------------------
def main():
    args = build_parser().parse_args()
    df = pd.read_csv(args.solution_csv)
    N  = len(df)

    # --------------------- 3‑D figure & static setup -----------------------
    fig = plt.figure(figsize=(8, 7))
    ax  = fig.add_subplot(111, projection="3d")
    fig.suptitle("Two‑flight trajectory animation")

    # Set fixed axis limits so the camera doesn’t jump
    pad = 0.1
    for axis, cols in zip([ax.set_xlim, ax.set_ylim, ax.set_zlim],
                          [(df.x1, df.x2), (df.y1, df.y2), (df.z1, df.z2)]):
        mins = min(map(np.min, cols))
        maxs = max(map(np.max, cols))
        rng  = maxs - mins
        axis(mins - rng*pad, maxs + rng*pad)

    ax.set_xlabel("x")
    ax.set_ylabel("y")
    ax.set_zlabel("z (ft)")

    # Initialise plot elements: path lines + position markers
    path1, = ax.plot([], [], [], lw=2, label="Flight 1", color="tab:blue")
    path2, = ax.plot([], [], [], lw=2, label="Flight 2", color="tab:orange")
    dot1  = ax.scatter([], [], [], s=40, color="tab:blue")
    dot2  = ax.scatter([], [], [], s=40, color="tab:orange")
    ax.legend()

    # -------------------------- animation func ----------------------------
    def init():
        path1.set_data([], [])
        path1.set_3d_properties([])
        path2.set_data([], [])
        path2.set_3d_properties([])
        return path1, path2, dot1, dot2

    def update(frame):
        # Draw path up to 'frame'
        path1.set_data(df.x1[:frame], df.y1[:frame])
        path1.set_3d_properties(df.z1[:frame])
        path2.set_data(df.x2[:frame], df.y2[:frame])
        path2.set_3d_properties(df.z2[:frame])

        # Move the markers to current positions
        dot1._offsets3d = (np.array([df.x1[frame]]),
                           np.array([df.y1[frame]]),
                           np.array([df.z1[frame]]))
        dot2._offsets3d = (np.array([df.x2[frame]]),
                           np.array([df.y2[frame]]),
                           np.array([df.z2[frame]]))
        return path1, path2, dot1, dot2

    # ------------------------- create animation ---------------------------
    ani = FuncAnimation(fig, update, frames=N,
                        init_func=init, blit=True,
                        interval=2000/args.fps)

    # --------------------- save or just display ---------------------------
    if args.save_gif:
        print(f"Saving GIF → {args.save_gif}")
        ani.save(args.save_gif, writer=PillowWriter(fps=args.fps))
    elif args.save_mp4:
        print(f"Saving MP4 → {args.save_mp4}")
        ani.save(args.save_mp4, writer=FFMpegWriter(fps=args.fps))
    else:
        plt.show()


if __name__ == "__main__":
    main()
